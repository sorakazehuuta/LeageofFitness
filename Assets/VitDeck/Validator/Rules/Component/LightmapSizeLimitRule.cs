using System.Linq;
using System.Reflection;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;
using VitDeck.Language;

namespace VitDeck.Validator
{
    public class LightmapSizeLimitRule : BaseRule
    {
        private readonly int lightmapCountLimit;
        private readonly int lightmapAreaLimit;

        public LightmapSizeLimitRule(string name, int lightmapCountLimit,int lightmapAreaLimit) : base(name)
        {
            this.lightmapCountLimit = lightmapCountLimit;
            this.lightmapAreaLimit = lightmapAreaLimit;
        }

        protected override void Logic(ValidationTarget target)
        {
            var scenes = target.GetScenes();

            // 全てリアルタイムであればlightmapの検証は不要
            var staticRenderersCount = target.GetAllObjects()
                .Where(IsWrittenToLightmap)
                .SelectMany(obj => obj.GetComponents<Renderer>())
                .Count();

            if (staticRenderersCount == 0)
            {
                return;
            }

            foreach (var scene in scenes)
            {
                LogicForScene(scene);
            }

            var totalLightmapArea = GetTotalArea(target);
            if (totalLightmapArea > lightmapAreaLimit)
            {
                AddIssue(new Issue(
                    null,
                    IssueLevel.Error,
                    LocalizedMessage.Get("LightmapSizeLimitRule.Overarea", lightmapAreaLimit, totalLightmapArea),
                    LocalizedMessage.Get("LightmapSizeLimitRule.Overarea.Solution")));
            }

            if (IsLightMapAutoGenerated())
            {
                AddIssue(new Issue(
                    null,
                    IssueLevel.Error,
                    LocalizedMessage.Get("LightmapSizeLimitRule.MustLightmapBakingManually"),
                    LocalizedMessage.Get("LightmapSizeLimitRule.MustLightmapBakingManually.Solution")));
            }
        }

        private bool IsWrittenToLightmap(GameObject obj)
        {
            if (!obj.activeInHierarchy)
            {
                return false;
            }

            var objStaticFlags = GameObjectUtility.GetStaticEditorFlags(obj);
            if ((objStaticFlags & StaticEditorFlags.ContributeGI) != StaticEditorFlags.ContributeGI)
            {
                return false;
            }

            return true;
        }

        void LogicForScene(Scene scene)
        {
            var lightmaps = LightmapSettings.lightmaps;
            if (lightmaps.Length > lightmapCountLimit)
            {
                AddIssue(new Issue(
                    null,
                    IssueLevel.Error,
                    LocalizedMessage.Get("LightmapSizeLimitRule.Overuse", lightmapCountLimit, lightmaps.Length),
                    LocalizedMessage.Get("LightmapSizeLimitRule.Overuse.Solution")
                    ));
            }
        }

        // LightmapTweakからロジックを借りる
        // TODO: MITライセンスなのでどこかにクレジットするやつ
        private static int GetTotalArea(ValidationTarget target)
        {
            var meshRenderers = target.GetRootObjects()
                // 非アクティブのオブジェクトも対象にする
                .SelectMany(r => r.GetComponentsInChildren<MeshRenderer>(true))
                .Where(mr => mr.receiveGI == ReceiveGI.Lightmaps && 0 < mr.scaleInLightmap)
                .Distinct();

            var totalArea = 0;

            // TODO: この方式で多重カウントされないかは要調査
            foreach (var renderer in meshRenderers)
            {
                var lightmapIndex = renderer.lightmapIndex;
                if (lightmapIndex < 0 || 65533 < lightmapIndex || LightmapSettings.lightmaps.Length <= lightmapIndex) {
                    continue;
                }

                var lightmap = LightmapSettings.lightmaps[lightmapIndex];
                var mesh = renderer.gameObject.GetComponent<MeshFilter>()?.sharedMesh;
                if (mesh == null)
                    continue;

                var uv = mesh.uv2.Length == 0 ? mesh.uv : mesh.uv2;
                if (uv.Length == 0)
                    continue;

                var so = renderer.lightmapScaleOffset;

                var uvMin = new Vector2(uv.Select(i => i.x).Min() * so.x + so.z, uv.Select(i => i.y).Min() * so.y + so.w);
                var uvMax = new Vector2(uv.Select(i => i.x).Max() * so.x + so.z, uv.Select(i => i.y).Max() * so.y + so.w);

                var width = Mathf.Abs(uvMax.x - uvMin.x) * lightmap.lightmapColor.width;
                var height = Mathf.Abs(uvMax.y - uvMin.y) * lightmap.lightmapColor.height;
                totalArea += Mathf.RoundToInt(width * height);
            }

            return totalArea;
        }

        static bool IsLightMapAutoGenerated()
        {
            var lightmapSettings = GetLighmapSettings();
            return lightmapSettings.FindProperty("m_GIWorkflowMode").intValue == 0;
        }

        static SerializedObject GetLighmapSettings()
        {
            var getLightmapSettingsMethod = typeof(LightmapEditorSettings)
                .GetMethod("GetLightmapSettings", BindingFlags.Static | BindingFlags.NonPublic);
            var lightmapSettings = getLightmapSettingsMethod.Invoke(null, null) as UnityEngine.Object;
            return new SerializedObject(lightmapSettings);
        }
    }
}